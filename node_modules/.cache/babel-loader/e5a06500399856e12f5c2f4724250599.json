{"ast":null,"code":"function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n\n  _setPrototypeOf(subClass, superClass);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _extends2() {\n  _extends2 = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends2.apply(this, arguments);\n} // Generated with Packemon: https://packemon.dev\n// Platform: browser, Support: stable, Format: esm\n\n\nimport React from 'react';\nimport escapeHtml from 'escape-html';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction Element(_ref) {\n  var _ref$attributes = _ref.attributes,\n      attributes = _ref$attributes === void 0 ? {} : _ref$attributes,\n      className = _ref.className,\n      _ref$children = _ref.children,\n      children = _ref$children === void 0 ? null : _ref$children,\n      _ref$selfClose = _ref.selfClose,\n      selfClose = _ref$selfClose === void 0 ? false : _ref$selfClose,\n      tagName = _ref.tagName;\n  var Tag = tagName;\n  return selfClose ? /*#__PURE__*/React.createElement(Tag, _extends({\n    className: className\n  }, attributes)) : /*#__PURE__*/React.createElement(Tag, _extends({\n    className: className\n  }, attributes), children);\n}\n\nvar Filter = /*#__PURE__*/function () {\n  function Filter() {}\n\n  var _proto = Filter.prototype;\n  /**\n   * Filter and clean an HTML attribute value.\n   */\n\n  _proto.attribute = function attribute(name, value) {\n    return value;\n  }\n  /**\n   * Filter and clean an HTML node.\n   */\n  ;\n\n  _proto.node = function node(name, _node) {\n    return _node;\n  };\n\n  return Filter;\n}();\n/* eslint-disable no-bitwise, no-magic-numbers, sort-keys */\n// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories\n\n\nvar TYPE_FLOW = 1;\nvar TYPE_SECTION = 1 << 1;\nvar TYPE_HEADING = 1 << 2;\nvar TYPE_PHRASING = 1 << 3;\nvar TYPE_EMBEDDED = 1 << 4;\nvar TYPE_INTERACTIVE = 1 << 5;\nvar TYPE_PALPABLE = 1 << 6; // https://developer.mozilla.org/en-US/docs/Web/HTML/Element\n\nvar tagConfigs = {\n  a: {\n    content: TYPE_FLOW | TYPE_PHRASING,\n    self: false,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  address: {\n    invalid: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'address', 'article', 'aside', 'section', 'div', 'header', 'footer'],\n    self: false\n  },\n  audio: {\n    children: ['track', 'source']\n  },\n  br: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true\n  },\n  body: {\n    content: TYPE_FLOW | TYPE_SECTION | TYPE_HEADING | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  button: {\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  caption: {\n    content: TYPE_FLOW,\n    parent: ['table']\n  },\n  col: {\n    parent: ['colgroup'],\n    void: true\n  },\n  colgroup: {\n    children: ['col'],\n    parent: ['table']\n  },\n  details: {\n    children: ['summary'],\n    type: TYPE_FLOW | TYPE_INTERACTIVE | TYPE_PALPABLE\n  },\n  dd: {\n    content: TYPE_FLOW,\n    parent: ['dl']\n  },\n  dl: {\n    children: ['dt', 'dd'],\n    type: TYPE_FLOW\n  },\n  dt: {\n    content: TYPE_FLOW,\n    invalid: ['footer', 'header'],\n    parent: ['dl']\n  },\n  figcaption: {\n    content: TYPE_FLOW,\n    parent: ['figure']\n  },\n  footer: {\n    invalid: ['footer', 'header']\n  },\n  header: {\n    invalid: ['footer', 'header']\n  },\n  hr: {\n    type: TYPE_FLOW,\n    void: true\n  },\n  img: {\n    void: true\n  },\n  li: {\n    content: TYPE_FLOW,\n    parent: ['ul', 'ol', 'menu']\n  },\n  main: {\n    self: false\n  },\n  ol: {\n    children: ['li'],\n    type: TYPE_FLOW\n  },\n  picture: {\n    children: ['source', 'img'],\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED\n  },\n  rb: {\n    parent: ['ruby', 'rtc']\n  },\n  rp: {\n    parent: ['ruby', 'rtc']\n  },\n  rt: {\n    content: TYPE_PHRASING,\n    parent: ['ruby', 'rtc']\n  },\n  rtc: {\n    content: TYPE_PHRASING,\n    parent: ['ruby']\n  },\n  ruby: {\n    children: ['rb', 'rp', 'rt', 'rtc']\n  },\n  source: {\n    parent: ['audio', 'video', 'picture'],\n    void: true\n  },\n  summary: {\n    content: TYPE_PHRASING,\n    parent: ['details']\n  },\n  table: {\n    children: ['caption', 'colgroup', 'thead', 'tbody', 'tfoot', 'tr'],\n    type: TYPE_FLOW\n  },\n  tbody: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  td: {\n    content: TYPE_FLOW,\n    parent: ['tr']\n  },\n  tfoot: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  th: {\n    content: TYPE_FLOW,\n    parent: ['tr']\n  },\n  thead: {\n    parent: ['table'],\n    children: ['tr']\n  },\n  tr: {\n    parent: ['table', 'tbody', 'thead', 'tfoot'],\n    children: ['th', 'td']\n  },\n  track: {\n    parent: ['audio', 'video'],\n    void: true\n  },\n  ul: {\n    children: ['li'],\n    type: TYPE_FLOW\n  },\n  video: {\n    children: ['track', 'source']\n  },\n  wbr: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true\n  }\n};\n\nfunction createConfigBuilder(config) {\n  return function (tagName) {\n    tagConfigs[tagName] = _extends2({}, config, tagConfigs[tagName]);\n  };\n}\n\n['address', 'main', 'div', 'figure', 'p', 'pre'].forEach(createConfigBuilder({\n  content: TYPE_FLOW,\n  type: TYPE_FLOW | TYPE_PALPABLE\n}));\n['abbr', 'b', 'bdi', 'bdo', 'cite', 'code', 'data', 'dfn', 'em', 'i', 'kbd', 'mark', 'q', 'ruby', 'samp', 'strong', 'sub', 'sup', 'time', 'u', 'var'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PHRASING | TYPE_PALPABLE\n}));\n['p', 'pre'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PALPABLE\n}));\n['s', 'small', 'span', 'del', 'ins'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_PHRASING\n}));\n['article', 'aside', 'footer', 'header', 'nav', 'section', 'blockquote'].forEach(createConfigBuilder({\n  content: TYPE_FLOW,\n  type: TYPE_FLOW | TYPE_SECTION | TYPE_PALPABLE\n}));\n['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(createConfigBuilder({\n  content: TYPE_PHRASING,\n  type: TYPE_FLOW | TYPE_HEADING | TYPE_PALPABLE\n}));\n['audio', 'canvas', 'iframe', 'img', 'video'].forEach(createConfigBuilder({\n  type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_PALPABLE\n})); // Disable this map from being modified\n\nvar TAGS = Object.freeze(tagConfigs); // Tags that should never be allowed, even if the allow list is disabled\n\nvar BANNED_TAG_LIST = ['applet', 'base', 'body', 'command', 'embed', 'frame', 'frameset', 'head', 'html', 'link', 'meta', 'noscript', 'object', 'script', 'style', 'title'];\nvar ALLOWED_TAG_LIST = Object.keys(TAGS).filter(function (tag) {\n  return tag !== 'canvas' && tag !== 'iframe';\n}); // Filters apply to HTML attributes\n\nvar FILTER_ALLOW = 1;\nvar FILTER_DENY = 2;\nvar FILTER_CAST_NUMBER = 3;\nvar FILTER_CAST_BOOL = 4;\nvar FILTER_NO_CAST = 5; // Attributes not listed here will be denied\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\n\nvar ATTRIBUTES = Object.freeze({\n  alt: FILTER_ALLOW,\n  cite: FILTER_ALLOW,\n  class: FILTER_ALLOW,\n  colspan: FILTER_CAST_NUMBER,\n  controls: FILTER_CAST_BOOL,\n  datetime: FILTER_ALLOW,\n  default: FILTER_CAST_BOOL,\n  disabled: FILTER_CAST_BOOL,\n  dir: FILTER_ALLOW,\n  height: FILTER_ALLOW,\n  href: FILTER_ALLOW,\n  id: FILTER_ALLOW,\n  kind: FILTER_ALLOW,\n  label: FILTER_ALLOW,\n  lang: FILTER_ALLOW,\n  loading: FILTER_ALLOW,\n  loop: FILTER_CAST_BOOL,\n  media: FILTER_ALLOW,\n  muted: FILTER_CAST_BOOL,\n  poster: FILTER_ALLOW,\n  role: FILTER_ALLOW,\n  rowspan: FILTER_CAST_NUMBER,\n  scope: FILTER_ALLOW,\n  sizes: FILTER_ALLOW,\n  span: FILTER_CAST_NUMBER,\n  start: FILTER_CAST_NUMBER,\n  style: FILTER_NO_CAST,\n  src: FILTER_ALLOW,\n  srclang: FILTER_ALLOW,\n  srcset: FILTER_ALLOW,\n  target: FILTER_ALLOW,\n  title: FILTER_ALLOW,\n  type: FILTER_ALLOW,\n  width: FILTER_ALLOW\n}); // Attributes to camel case for React props\n\nvar ATTRIBUTES_TO_PROPS = Object.freeze({\n  class: 'className',\n  colspan: 'colSpan',\n  datetime: 'dateTime',\n  rowspan: 'rowSpan',\n  srclang: 'srcLang',\n  srcset: 'srcSet'\n});\nvar INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nvar StyleFilter = /*#__PURE__*/function (_Filter) {\n  _inheritsLoose(StyleFilter, _Filter);\n\n  function StyleFilter() {\n    return _Filter.apply(this, arguments) || this;\n  }\n\n  var _proto2 = StyleFilter.prototype;\n\n  _proto2.attribute = function attribute(name, value) {\n    if (name === 'style') {\n      Object.keys(value).forEach(function (key) {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    }\n\n    return value;\n  };\n\n  return StyleFilter;\n}(Filter);\n/* eslint-disable no-bitwise, no-cond-assign, complexity */\n\n\nvar ELEMENT_NODE = 1;\nvar TEXT_NODE = 3;\nvar INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nvar ALLOWED_ATTRS = /^(aria\\x2D|data\\x2D|[0-9A-Z_a-z\\u017F\\u212A]+:)/i;\nvar OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(markup, props, matchers, filters) {\n    if (props === void 0) {\n      props = {};\n    }\n\n    if (matchers === void 0) {\n      matchers = [];\n    }\n\n    if (filters === void 0) {\n      filters = [];\n    }\n\n    this.allowed = void 0;\n    this.banned = void 0;\n    this.blocked = void 0;\n    this.container = void 0;\n    this.content = [];\n    this.props = void 0;\n    this.matchers = void 0;\n    this.filters = void 0;\n    this.keyIndex = void 0;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (markup && typeof markup !== 'string') {\n        throw new TypeError('Interweave parser requires a valid string.');\n      }\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [].concat(filters, [new StyleFilter()]);\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set(props.allowList || ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n\n\n  var _proto3 = Parser.prototype;\n\n  _proto3.applyAttributeFilters = function applyAttributeFilters(name, value) {\n    return this.filters.reduce(function (nextValue, filter) {\n      return nextValue !== null && typeof filter.attribute === 'function' ? filter.attribute(name, nextValue) : nextValue;\n    }, value);\n  }\n  /**\n   * Loop through and apply all registered node filters.\n   */\n  ;\n\n  _proto3.applyNodeFilters = function applyNodeFilters(name, node) {\n    // Allow null to be returned\n    return this.filters.reduce(function (nextNode, filter) {\n      return nextNode !== null && typeof filter.node === 'function' ? filter.node(name, nextNode) : nextNode;\n    }, node);\n  }\n  /**\n   * Loop through and apply all registered matchers to the string.\n   * If a match is found, create a React element, and build a new array.\n   * This array allows React to interpolate and render accordingly.\n   */\n  ;\n\n  _proto3.applyMatchers = function applyMatchers(string, parentConfig) {\n    var _this = this;\n\n    var elements = {};\n    var props = this.props;\n    var matchedString = string;\n    var elementIndex = 0;\n    var parts = null;\n    this.matchers.forEach(function (matcher) {\n      var tagName = matcher.asTag().toLowerCase();\n\n      var config = _this.getTagConfig(tagName); // Skip matchers that have been disabled from props or are not supported\n\n\n      if (props[matcher.inverseName] || !_this.isTagAllowed(tagName)) {\n        return;\n      } // Skip matchers in which the child cannot be rendered\n\n\n      if (!_this.canRenderChild(parentConfig, config)) {\n        return;\n      } // Continuously trigger the matcher until no matches are found\n\n\n      var tokenizedString = '';\n\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        var _parts = parts,\n            index = _parts.index,\n            length = _parts.length,\n            _match = _parts.match,\n            valid = _parts.valid,\n            isVoid = _parts.void,\n            partProps = _objectWithoutPropertiesLoose(_parts, [\"index\", \"length\", \"match\", \"valid\", \"void\"]);\n\n        var tokenName = matcher.propName + elementIndex; // Piece together a new string with interpolated tokens\n\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n\n        if (valid) {\n          tokenizedString += isVoid ? \"{{{\" + tokenName + \"/}}}\" : \"{{{\" + tokenName + \"}}}\" + _match + \"{{{/\" + tokenName + \"}}}\";\n          _this.keyIndex += 1;\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: _match,\n            matcher: matcher,\n            props: _extends2({}, props, partProps, {\n              key: _this.keyIndex\n            })\n          };\n        } else {\n          tokenizedString += _match;\n        } // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n\n\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || _match.length));\n        }\n      } // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n\n\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n\n    if (elementIndex === 0) {\n      return string;\n    }\n\n    return this.replaceTokens(matchedString, elements);\n  }\n  /**\n   * Determine whether the child can be rendered within the parent.\n   */\n  ;\n\n  _proto3.canRenderChild = function canRenderChild(parentConfig, childConfig) {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    } // No children\n\n\n    if (parentConfig.void) {\n      return false;\n    } // Valid children\n\n\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    } // Valid parent\n\n\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    } // Self nesting\n\n\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    } // Content category type\n\n\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n  /**\n   * Convert line breaks in a string to HTML `<br/>` tags.\n   * If the string contains HTML, we should not convert anything,\n   * as line breaks should be handled by `<br/>`s in the markup itself.\n   */\n  ;\n\n  _proto3.convertLineBreaks = function convertLineBreaks(markup) {\n    var _this$props = this.props,\n        noHtml = _this$props.noHtml,\n        disableLineBreaks = _this$props.disableLineBreaks;\n\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    } // Replace carriage returns\n\n\n    var nextMarkup = markup.replace(/\\r\\n/g, '\\n'); // Replace long line feeds\n\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n'); // Replace line feeds with `<br/>`s\n\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n    return nextMarkup;\n  }\n  /**\n   * Create a detached HTML document that allows for easy HTML\n   * parsing while not triggering scripts or loading external\n   * resources.\n   */\n  ;\n\n  _proto3.createContainer = function createContainer(markup) {\n    var factory = typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL || createDocument;\n    var doc = factory();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    var tag = this.props.containerTagName || 'body';\n    var el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n    if (markup.match(INVALID_ROOTS)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n\n    return el;\n  }\n  /**\n   * Convert an elements attribute map to an object map.\n   * Returns null if no attributes are defined.\n   */\n  ;\n\n  _proto3.extractAttributes = function extractAttributes(node) {\n    var _this2 = this;\n\n    var allowAttributes = this.props.allowAttributes;\n    var attributes = {};\n    var count = 0;\n\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    }\n\n    Array.from(node.attributes).forEach(function (attr) {\n      var name = attr.name,\n          value = attr.value;\n      var newName = name.toLowerCase();\n      var filter = ATTRIBUTES[newName] || ATTRIBUTES[name]; // Verify the node is safe from attacks\n\n      if (!_this2.isSafe(node)) {\n        return;\n      } // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n\n\n      if (!newName.match(ALLOWED_ATTRS)) {\n        if (!allowAttributes && (!filter || filter === FILTER_DENY) || newName.startsWith('on') || value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i)) {\n          return;\n        }\n      } // Apply attribute filters\n\n\n      var newValue = newName === 'style' ? _this2.extractStyleAttribute(node) : value; // Cast to boolean\n\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true; // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue)); // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = _this2.applyAttributeFilters(newName, newValue);\n      count += 1;\n    });\n\n    if (count === 0) {\n      return null;\n    }\n\n    return attributes;\n  }\n  /**\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\n   */\n  ;\n\n  _proto3.extractStyleAttribute = function extractStyleAttribute(node) {\n    var styles = {};\n    Array.from(node.style).forEach(function (key) {\n      var value = node.style[key];\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, function (match, letter) {\n          return letter.toUpperCase();\n        })] = value;\n      }\n    });\n    return styles;\n  }\n  /**\n   * Return configuration for a specific tag.\n   */\n  ;\n\n  _proto3.getTagConfig = function getTagConfig(tagName) {\n    var common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false\n    }; // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n\n    if (TAGS[tagName]) {\n      return _extends2({}, common, TAGS[tagName], {\n        tagName: tagName\n      });\n    }\n\n    return common;\n  }\n  /**\n   * Verify that a node is safe from XSS and injection attacks.\n   */\n  ;\n\n  _proto3.isSafe = function isSafe(node) {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      var href = node.getAttribute('href'); // Fragment protocols start with about:\n      // So let's just allow them\n\n      if (href && href.charAt(0) === '#') {\n        return true;\n      }\n\n      var protocol = node.protocol.toLowerCase();\n      return protocol === ':' || protocol === 'http:' || protocol === 'https:' || protocol === 'mailto:' || protocol === 'tel:';\n    }\n\n    return true;\n  }\n  /**\n   * Verify that an HTML tag is allowed to render.\n   */\n  ;\n\n  _proto3.isTagAllowed = function isTagAllowed(tagName) {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    }\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n  /**\n   * Parse the markup by injecting it into a detached document,\n   * while looping over all child nodes and generating an\n   * array to interpolate into JSX.\n   */\n  ;\n\n  _proto3.parse = function parse() {\n    if (!this.container) {\n      return [];\n    }\n\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n  /**\n   * Loop over the nodes children and generate a\n   * list of text nodes and React elements.\n   */\n  ;\n\n  _proto3.parseNode = function parseNode(parentNode, parentConfig) {\n    var _this3 = this;\n\n    var _this$props2 = this.props,\n        noHtml = _this$props2.noHtml,\n        noHtmlExceptMatchers = _this$props2.noHtmlExceptMatchers,\n        allowElements = _this$props2.allowElements,\n        transform = _this$props2.transform,\n        transformOnlyAllowList = _this$props2.transformOnlyAllowList;\n    var content = [];\n    var mergedText = '';\n    Array.from(parentNode.childNodes).forEach(function (node) {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        var tagName = node.nodeName.toLowerCase();\n\n        var config = _this3.getTagConfig(tagName); // Persist any previous text\n\n\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        } // Apply node filters first\n\n\n        var nextNode = _this3.applyNodeFilters(tagName, node);\n\n        if (!nextNode) {\n          return;\n        } // Apply transformation second\n\n\n        var children;\n\n        if (transform && !(transformOnlyAllowList && !_this3.isTagAllowed(tagName))) {\n          _this3.keyIndex += 1;\n          var key = _this3.keyIndex; // Must occur after key is set\n\n          children = _this3.parseNode(nextNode, config);\n          var transformed = transform(nextNode, children, config);\n\n          if (transformed === null) {\n            return;\n          } else if (typeof transformed !== 'undefined') {\n            content.push( /*#__PURE__*/React.cloneElement(transformed, {\n              key: key\n            }));\n            return;\n          } // Reset as we're not using the transformation\n\n\n          _this3.keyIndex = key - 1;\n        } // Never allow these tags (except via a transformer)\n\n\n        if (_this3.banned.has(tagName)) {\n          return;\n        } // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n\n\n        if (!(noHtml || noHtmlExceptMatchers && tagName !== 'br') && _this3.isTagAllowed(tagName) && (allowElements || _this3.canRenderChild(parentConfig, config))) {\n          _this3.keyIndex += 1; // Build the props as it makes it easier to test\n\n          var attributes = _this3.extractAttributes(nextNode);\n\n          var elementProps = {\n            tagName: tagName\n          };\n\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n\n          content.push( /*#__PURE__*/React.createElement(Element, _extends2({}, elementProps, {\n            key: _this3.keyIndex\n          }), children || _this3.parseNode(nextNode, config))); // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = content.concat(_this3.parseNode(nextNode, config.tagName ? config : parentConfig));\n        } // Apply matchers if a text node\n\n      } else if (node.nodeType === TEXT_NODE) {\n        var text = noHtml && !noHtmlExceptMatchers ? node.textContent : _this3.applyMatchers(node.textContent || '', parentConfig);\n\n        if (Array.isArray(text)) {\n          content = content.concat(text);\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n\n    if (mergedText) {\n      content.push(mergedText);\n    }\n\n    return content;\n  }\n  /**\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\n   * so that React can render it correctly.\n   */\n  ;\n\n  _proto3.replaceTokens = function replaceTokens(tokenizedString, elements) {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n\n    var nodes = [];\n    var text = tokenizedString;\n    var open = null; // Find an open token tag\n\n    while (open = text.match(OPEN_TOKEN)) {\n      var _open = open,\n          _match2 = _open[0],\n          tokenName = _open[1];\n      var startIndex = open.index;\n\n      var isVoid = _match2.includes('/');\n\n      if (process.env.NODE_ENV !== \"production\") {\n        if (!elements[tokenName]) {\n          throw new Error(\"Token \\\"\" + tokenName + \"\\\" found but no matching element to replace with.\");\n        }\n      } // Extract the previous non-token text\n\n\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex)); // Reduce text so that the closing tag will be found after the opening\n\n        text = text.slice(startIndex);\n      }\n\n      var _elements$tokenName = elements[tokenName],\n          children = _elements$tokenName.children,\n          matcher = _elements$tokenName.matcher,\n          elementProps = _elements$tokenName.props;\n      var endIndex = void 0; // Use tag as-is if void\n\n      if (isVoid) {\n        endIndex = _match2.length;\n        nodes.push(matcher.createElement(children, elementProps)); // Find the closing tag if not void\n      } else {\n        var close = text.match(new RegExp(\"{{{/\" + tokenName + \"}}}\"));\n\n        if (process.env.NODE_ENV !== \"production\") {\n          if (!close) {\n            throw new Error(\"Closing token missing for interpolated element \\\"\" + tokenName + \"\\\".\");\n          }\n        }\n\n        endIndex = close.index + close[0].length;\n        nodes.push(matcher.createElement(this.replaceTokens(text.slice(_match2.length, close.index), elements), elementProps));\n      } // Reduce text for the next interation\n\n\n      text = text.slice(endIndex);\n    } // Extra the remaining text\n\n\n    if (text.length > 0) {\n      nodes.push(text);\n    } // Reduce to a string if possible\n\n\n    if (nodes.length === 0) {\n      return '';\n    } else if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n\n    return nodes;\n  };\n\n  return Parser;\n}();\n/* eslint-disable react/jsx-fragments */\n\n\nfunction Markup(props) {\n  var attributes = props.attributes,\n      className = props.className,\n      containerTagName = props.containerTagName,\n      content = props.content,\n      emptyContent = props.emptyContent,\n      parsedContent = props.parsedContent,\n      tagName = props.tagName;\n  var tag = containerTagName || tagName || 'span';\n  var noWrap = tag === 'fragment' ? true : props.noWrap;\n  var mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    var markup = new Parser(content || '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return /*#__PURE__*/React.createElement(React.Fragment, null, mainContent);\n  }\n\n  return /*#__PURE__*/React.createElement(Element, {\n    attributes: attributes,\n    className: className,\n    tagName: tag\n  }, mainContent);\n}\n\nfunction Interweave(props) {\n  var attributes = props.attributes,\n      className = props.className,\n      _props$content = props.content,\n      content = _props$content === void 0 ? '' : _props$content,\n      _props$disableFilters = props.disableFilters,\n      disableFilters = _props$disableFilters === void 0 ? false : _props$disableFilters,\n      _props$disableMatcher = props.disableMatchers,\n      disableMatchers = _props$disableMatcher === void 0 ? false : _props$disableMatcher,\n      _props$emptyContent = props.emptyContent,\n      emptyContent = _props$emptyContent === void 0 ? null : _props$emptyContent,\n      _props$filters = props.filters,\n      filters = _props$filters === void 0 ? [] : _props$filters,\n      _props$matchers = props.matchers,\n      matchers = _props$matchers === void 0 ? [] : _props$matchers,\n      _props$onAfterParse = props.onAfterParse,\n      onAfterParse = _props$onAfterParse === void 0 ? null : _props$onAfterParse,\n      _props$onBeforeParse = props.onBeforeParse,\n      onBeforeParse = _props$onBeforeParse === void 0 ? null : _props$onBeforeParse,\n      _props$tagName = props.tagName,\n      tagName = _props$tagName === void 0 ? 'span' : _props$tagName,\n      _props$noWrap = props.noWrap,\n      noWrap = _props$noWrap === void 0 ? false : _props$noWrap,\n      parserProps = _objectWithoutPropertiesLoose(props, [\"attributes\", \"className\", \"content\", \"disableFilters\", \"disableMatchers\", \"emptyContent\", \"filters\", \"matchers\", \"onAfterParse\", \"onBeforeParse\", \"tagName\", \"noWrap\"]);\n\n  var allMatchers = disableMatchers ? [] : matchers;\n  var allFilters = disableFilters ? [] : filters;\n  var beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  var afterCallbacks = onAfterParse ? [onAfterParse] : []; // Inherit callbacks from matchers\n\n  allMatchers.forEach(function (matcher) {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  }); // Trigger before callbacks\n\n  var markup = beforeCallbacks.reduce(function (string, callback) {\n    var nextString = callback(string, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof nextString !== 'string') {\n        throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n      }\n    }\n\n    return nextString;\n  }, content || ''); // Parse the markup\n\n  var parser = new Parser(markup, parserProps, allMatchers, allFilters); // Trigger after callbacks\n\n  var nodes = afterCallbacks.reduce(function (parserNodes, callback) {\n    var nextNodes = callback(parserNodes, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(nextNodes)) {\n        throw new TypeError('Interweave `onAfterParse` must return an array of strings and React elements.');\n      }\n    }\n\n    return nextNodes;\n  }, parser.parse());\n  return /*#__PURE__*/React.createElement(Markup, {\n    attributes: attributes,\n    className: className,\n    containerTagName: props.containerTagName,\n    emptyContent: emptyContent,\n    tagName: tagName,\n    noWrap: noWrap,\n    parsedContent: nodes.length === 0 ? undefined : nodes\n  });\n}\n/**\n * Trigger the actual pattern match and package the matched\n * response through a callback.\n */\n\n\nfunction match(string, pattern, callback, isVoid) {\n  if (isVoid === void 0) {\n    isVoid = false;\n  }\n\n  var matches = string.match(pattern instanceof RegExp ? pattern : new RegExp(pattern, 'i'));\n\n  if (!matches) {\n    return null;\n  }\n\n  return _extends2({\n    match: matches[0],\n    void: isVoid\n  }, callback(matches), {\n    index: matches.index,\n    length: matches[0].length,\n    valid: true\n  });\n}\n\nvar Matcher = /*#__PURE__*/function () {\n  function Matcher(name, options, factory) {\n    this.greedy = false;\n    this.options = void 0;\n    this.propName = void 0;\n    this.inverseName = void 0;\n    this.factory = void 0;\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!name || name.toLowerCase() === 'html') {\n        throw new Error(\"The matcher name \\\"\" + name + \"\\\" is not allowed.\");\n      }\n    } // @ts-expect-error\n\n\n    this.options = _extends2({}, options);\n    this.propName = name;\n    this.inverseName = \"no\" + (name.charAt(0).toUpperCase() + name.slice(1));\n    this.factory = factory || null;\n  }\n  /**\n   * Attempts to create a React element using a custom user provided factory,\n   * or the default matcher factory.\n   */\n\n\n  var _proto4 = Matcher.prototype;\n\n  _proto4.createElement = function createElement(children, props) {\n    var element = this.factory ? /*#__PURE__*/React.createElement(this.factory, props, children) : this.replaceWith(children, props);\n\n    if (process.env.NODE_ENV !== \"production\") {\n      if (typeof element !== 'string' && ! /*#__PURE__*/React.isValidElement(element)) {\n        throw new Error(\"Invalid React element created from \" + this.constructor.name + \".\");\n      }\n    }\n\n    return element;\n  }\n  /**\n   * Trigger the actual pattern match and package the matched\n   * response through a callback.\n   */\n  ;\n\n  _proto4.doMatch = function doMatch(string, pattern, callback, isVoid) {\n    if (isVoid === void 0) {\n      isVoid = false;\n    }\n\n    return match(string, pattern, callback, isVoid);\n  }\n  /**\n   * Callback triggered before parsing.\n   */\n  ;\n\n  _proto4.onBeforeParse = function onBeforeParse(content, props) {\n    return content;\n  }\n  /**\n   * Callback triggered after parsing.\n   */\n  ;\n\n  _proto4.onAfterParse = function onAfterParse(content, props) {\n    return content;\n  }\n  /**\n   * Replace the match with a React element based on the matched token and optional props.\n   */\n  ;\n\n  return Matcher;\n}();\n/**\n * @copyright   2016-2019, Miles Johnson\n * @license     https://opensource.org/licenses/MIT\n */\n\n\nexport default Interweave;\nexport { ALLOWED_TAG_LIST, ATTRIBUTES, ATTRIBUTES_TO_PROPS, BANNED_TAG_LIST, Element, FILTER_ALLOW, FILTER_CAST_BOOL, FILTER_CAST_NUMBER, FILTER_DENY, FILTER_NO_CAST, Filter, Markup, Matcher, Parser, TAGS, TYPE_EMBEDDED, TYPE_FLOW, TYPE_HEADING, TYPE_INTERACTIVE, TYPE_PALPABLE, TYPE_PHRASING, TYPE_SECTION, match };","map":{"version":3,"sources":["/Users/reneelightner/reneelempert/react-development-course-materials/final/node_modules/interweave/src/Element.tsx","/Users/reneelightner/reneelempert/react-development-course-materials/final/node_modules/interweave/src/Filter.ts","/Users/reneelightner/reneelempert/react-development-course-materials/final/node_modules/interweave/src/constants.ts","/Users/reneelightner/reneelempert/react-development-course-materials/final/node_modules/interweave/src/StyleFilter.ts","/Users/reneelightner/reneelempert/react-development-course-materials/final/node_modules/interweave/src/Parser.ts","/Users/reneelightner/reneelempert/react-development-course-materials/final/node_modules/interweave/src/Markup.tsx","/Users/reneelightner/reneelempert/react-development-course-materials/final/node_modules/interweave/src/Interweave.tsx","/Users/reneelightner/reneelempert/react-development-course-materials/final/node_modules/interweave/src/match.ts","/Users/reneelightner/reneelempert/react-development-course-materials/final/node_modules/interweave/src/Matcher.ts","/Users/reneelightner/reneelempert/react-development-course-materials/final/node_modules/interweave/src/index.ts"],"names":["children","selfClose","className","Filter","attribute","name","TYPE_FLOW","TYPE_SECTION","TYPE_EMBEDDED","TYPE_INTERACTIVE","TYPE_PALPABLE","tagConfigs","a","address","invalid","self","audio","type","void","body","content","button","TYPE_PHRASING","caption","col","parent","colgroup","details","header","img","main","ol","picture","rp","rt","rtc","ruby","source","summary","table","tbody","tfoot","thead","track","video","wbr","forEach","createConfigBuilder","TAGS","Object","BANNED_TAG_LIST","FILTER_ALLOW","FILTER_DENY","FILTER_CAST_BOOL","FILTER_NO_CAST","ATTRIBUTES","cite","class","colspan","FILTER_CAST_NUMBER","controls","default","disabled","dir","height","href","label","lang","loading","loop","media","muted","poster","role","rowspan","scope","sizes","span","start","style","src","srclang","srcset","target","title","width","ATTRIBUTES_TO_PROPS","datetime","INVALID_STYLES","StyleFilter","String","value","match","TEXT_NODE","OPEN_TOKEN","createDocument","window","undefined","allowed","banned","container","props","keyIndex","constructor","markup","applyAttributeFilters","applyNodeFilters","applyMatchers","matchedString","elementIndex","matcher","tagName","getTagConfig","canRenderChild","valid","partProps","tokenizedString","elements","key","replaceTokens","parentConfig","childConfig","includes","convertLineBreaks","nextMarkup","createContainer","el","tag","createElement","Array","newName","filter","allowAttributes","newValue","attributes","count","extractStyleAttribute","from","node","styles","common","HTMLAnchorElement","isTagAllowed","parse","parseNode","noHtmlExceptMatchers","allowElements","has","elementProps","text","mergedText","nodes","open","tokenName","__DEV__","isVoid","endIndex","close","length","Markup","containerTagName","parsedContent","noWrap","mainContent","matchers","onAfterParse","onBeforeParse","parserProps","allMatchers","allFilters","disableFilters","beforeCallbacks","afterCallbacks","nextString","parser","isArray","TypeError","emptyContent","string","pattern","index","matches","options","propName","inverseName","factory","element"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { ElementProps } from './types';\n\nexport default function Element({\n  attributes = {},\n  className,\n  children = null,\n  selfClose = false,\n  tagName,\n}: ElementProps) {\n  const Tag = tagName as 'span';\n\n  return selfClose ? (\n    <Tag className={className} {...attributes} />\n  ) : (\n    <Tag className={className} {...attributes}>\n      {children}\n    </Tag>\n  );\n}\n","import { ElementAttributes, FilterInterface } from './types';\n\nexport default class Filter implements FilterInterface {\n  /**\n   * Filter and clean an HTML attribute value.\n   */\n  attribute<K extends keyof ElementAttributes>(\n    name: K,\n    value: ElementAttributes[K],\n  ): ElementAttributes[K] | null | undefined {\n    return value;\n  }\n\n  /**\n   * Filter and clean an HTML node.\n   */\n  node(name: string, node: HTMLElement): HTMLElement | null {\n    return node;\n  }\n}\n","/* eslint-disable no-bitwise, no-magic-numbers, sort-keys */\n\nimport { ConfigMap, FilterMap, NodeConfig } from './types';\n\n// https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Content_categories\nexport const TYPE_FLOW = 1;\nexport const TYPE_SECTION = 1 << 1;\nexport const TYPE_HEADING = 1 << 2;\nexport const TYPE_PHRASING = 1 << 3;\nexport const TYPE_EMBEDDED = 1 << 4;\nexport const TYPE_INTERACTIVE = 1 << 5;\nexport const TYPE_PALPABLE = 1 << 6;\n\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Element\nconst tagConfigs: { [tagName: string]: Partial<NodeConfig> } = {\n  a: {\n    content: TYPE_FLOW | TYPE_PHRASING,\n    self: false,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE,\n  },\n  address: {\n    invalid: [\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'h5',\n      'h6',\n      'address',\n      'article',\n      'aside',\n      'section',\n      'div',\n      'header',\n      'footer',\n    ],\n    self: false,\n  },\n  audio: {\n    children: ['track', 'source'],\n  },\n  br: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true,\n  },\n  body: {\n    content:\n      TYPE_FLOW |\n      TYPE_SECTION |\n      TYPE_HEADING |\n      TYPE_PHRASING |\n      TYPE_EMBEDDED |\n      TYPE_INTERACTIVE |\n      TYPE_PALPABLE,\n  },\n  button: {\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_INTERACTIVE | TYPE_PALPABLE,\n  },\n  caption: {\n    content: TYPE_FLOW,\n    parent: ['table'],\n  },\n  col: {\n    parent: ['colgroup'],\n    void: true,\n  },\n  colgroup: {\n    children: ['col'],\n    parent: ['table'],\n  },\n  details: {\n    children: ['summary'],\n    type: TYPE_FLOW | TYPE_INTERACTIVE | TYPE_PALPABLE,\n  },\n  dd: {\n    content: TYPE_FLOW,\n    parent: ['dl'],\n  },\n  dl: {\n    children: ['dt', 'dd'],\n    type: TYPE_FLOW,\n  },\n  dt: {\n    content: TYPE_FLOW,\n    invalid: ['footer', 'header'],\n    parent: ['dl'],\n  },\n  figcaption: {\n    content: TYPE_FLOW,\n    parent: ['figure'],\n  },\n  footer: {\n    invalid: ['footer', 'header'],\n  },\n  header: {\n    invalid: ['footer', 'header'],\n  },\n  hr: {\n    type: TYPE_FLOW,\n    void: true,\n  },\n  img: {\n    void: true,\n  },\n  li: {\n    content: TYPE_FLOW,\n    parent: ['ul', 'ol', 'menu'],\n  },\n  main: {\n    self: false,\n  },\n  ol: {\n    children: ['li'],\n    type: TYPE_FLOW,\n  },\n  picture: {\n    children: ['source', 'img'],\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED,\n  },\n  rb: {\n    parent: ['ruby', 'rtc'],\n  },\n  rp: {\n    parent: ['ruby', 'rtc'],\n  },\n  rt: {\n    content: TYPE_PHRASING,\n    parent: ['ruby', 'rtc'],\n  },\n  rtc: {\n    content: TYPE_PHRASING,\n    parent: ['ruby'],\n  },\n  ruby: {\n    children: ['rb', 'rp', 'rt', 'rtc'],\n  },\n  source: {\n    parent: ['audio', 'video', 'picture'],\n    void: true,\n  },\n  summary: {\n    content: TYPE_PHRASING,\n    parent: ['details'],\n  },\n  table: {\n    children: ['caption', 'colgroup', 'thead', 'tbody', 'tfoot', 'tr'],\n    type: TYPE_FLOW,\n  },\n  tbody: {\n    parent: ['table'],\n    children: ['tr'],\n  },\n  td: {\n    content: TYPE_FLOW,\n    parent: ['tr'],\n  },\n  tfoot: {\n    parent: ['table'],\n    children: ['tr'],\n  },\n  th: {\n    content: TYPE_FLOW,\n    parent: ['tr'],\n  },\n  thead: {\n    parent: ['table'],\n    children: ['tr'],\n  },\n  tr: {\n    parent: ['table', 'tbody', 'thead', 'tfoot'],\n    children: ['th', 'td'],\n  },\n  track: {\n    parent: ['audio', 'video'],\n    void: true,\n  },\n  ul: {\n    children: ['li'],\n    type: TYPE_FLOW,\n  },\n  video: {\n    children: ['track', 'source'],\n  },\n  wbr: {\n    type: TYPE_FLOW | TYPE_PHRASING,\n    void: true,\n  },\n};\n\nfunction createConfigBuilder(config: Partial<NodeConfig>): (tagName: string) => void {\n  return (tagName: string) => {\n    tagConfigs[tagName] = {\n      ...config,\n      ...tagConfigs[tagName],\n    };\n  };\n}\n\n['address', 'main', 'div', 'figure', 'p', 'pre'].forEach(\n  createConfigBuilder({\n    content: TYPE_FLOW,\n    type: TYPE_FLOW | TYPE_PALPABLE,\n  }),\n);\n\n[\n  'abbr',\n  'b',\n  'bdi',\n  'bdo',\n  'cite',\n  'code',\n  'data',\n  'dfn',\n  'em',\n  'i',\n  'kbd',\n  'mark',\n  'q',\n  'ruby',\n  'samp',\n  'strong',\n  'sub',\n  'sup',\n  'time',\n  'u',\n  'var',\n].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_PALPABLE,\n  }),\n);\n\n['p', 'pre'].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PALPABLE,\n  }),\n);\n\n['s', 'small', 'span', 'del', 'ins'].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_PHRASING,\n  }),\n);\n\n['article', 'aside', 'footer', 'header', 'nav', 'section', 'blockquote'].forEach(\n  createConfigBuilder({\n    content: TYPE_FLOW,\n    type: TYPE_FLOW | TYPE_SECTION | TYPE_PALPABLE,\n  }),\n);\n\n['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].forEach(\n  createConfigBuilder({\n    content: TYPE_PHRASING,\n    type: TYPE_FLOW | TYPE_HEADING | TYPE_PALPABLE,\n  }),\n);\n\n['audio', 'canvas', 'iframe', 'img', 'video'].forEach(\n  createConfigBuilder({\n    type: TYPE_FLOW | TYPE_PHRASING | TYPE_EMBEDDED | TYPE_PALPABLE,\n  }),\n);\n\n// Disable this map from being modified\nexport const TAGS: ConfigMap = Object.freeze(tagConfigs);\n\n// Tags that should never be allowed, even if the allow list is disabled\nexport const BANNED_TAG_LIST = [\n  'applet',\n  'base',\n  'body',\n  'command',\n  'embed',\n  'frame',\n  'frameset',\n  'head',\n  'html',\n  'link',\n  'meta',\n  'noscript',\n  'object',\n  'script',\n  'style',\n  'title',\n];\n\nexport const ALLOWED_TAG_LIST = Object.keys(TAGS).filter(\n  (tag) => tag !== 'canvas' && tag !== 'iframe',\n);\n\n// Filters apply to HTML attributes\nexport const FILTER_ALLOW = 1;\nexport const FILTER_DENY = 2;\nexport const FILTER_CAST_NUMBER = 3;\nexport const FILTER_CAST_BOOL = 4;\nexport const FILTER_NO_CAST = 5;\n\n// Attributes not listed here will be denied\n// https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes\nexport const ATTRIBUTES: FilterMap = Object.freeze({\n  alt: FILTER_ALLOW,\n  cite: FILTER_ALLOW,\n  class: FILTER_ALLOW,\n  colspan: FILTER_CAST_NUMBER,\n  controls: FILTER_CAST_BOOL,\n  datetime: FILTER_ALLOW,\n  default: FILTER_CAST_BOOL,\n  disabled: FILTER_CAST_BOOL,\n  dir: FILTER_ALLOW,\n  height: FILTER_ALLOW,\n  href: FILTER_ALLOW,\n  id: FILTER_ALLOW,\n  kind: FILTER_ALLOW,\n  label: FILTER_ALLOW,\n  lang: FILTER_ALLOW,\n  loading: FILTER_ALLOW,\n  loop: FILTER_CAST_BOOL,\n  media: FILTER_ALLOW,\n  muted: FILTER_CAST_BOOL,\n  poster: FILTER_ALLOW,\n  role: FILTER_ALLOW,\n  rowspan: FILTER_CAST_NUMBER,\n  scope: FILTER_ALLOW,\n  sizes: FILTER_ALLOW,\n  span: FILTER_CAST_NUMBER,\n  start: FILTER_CAST_NUMBER,\n  style: FILTER_NO_CAST,\n  src: FILTER_ALLOW,\n  srclang: FILTER_ALLOW,\n  srcset: FILTER_ALLOW,\n  target: FILTER_ALLOW,\n  title: FILTER_ALLOW,\n  type: FILTER_ALLOW,\n  width: FILTER_ALLOW,\n});\n\n// Attributes to camel case for React props\nexport const ATTRIBUTES_TO_PROPS: { [key: string]: string } = Object.freeze({\n  class: 'className',\n  colspan: 'colSpan',\n  datetime: 'dateTime',\n  rowspan: 'rowSpan',\n  srclang: 'srcLang',\n  srcset: 'srcSet',\n});\n","import Filter from './Filter';\nimport { ElementAttributes } from './types';\n\nconst INVALID_STYLES = /(url|image|image-set)\\(/i;\n\nexport default class StyleFilter extends Filter {\n  attribute<K extends keyof ElementAttributes>(\n    name: K,\n    value: ElementAttributes[K],\n  ): ElementAttributes[K] {\n    if (name === 'style') {\n      Object.keys(value).forEach((key) => {\n        if (String(value[key]).match(INVALID_STYLES)) {\n          // eslint-disable-next-line no-param-reassign\n          delete value[key];\n        }\n      });\n    }\n\n    return value;\n  }\n}\n","/* eslint-disable no-bitwise, no-cond-assign, complexity */\n\nimport React from 'react';\nimport escapeHtml from 'escape-html';\nimport {\n  ALLOWED_TAG_LIST,\n  ATTRIBUTES,\n  ATTRIBUTES_TO_PROPS,\n  BANNED_TAG_LIST,\n  FILTER_CAST_BOOL,\n  FILTER_CAST_NUMBER,\n  FILTER_DENY,\n  FILTER_NO_CAST,\n  TAGS,\n} from './constants';\nimport Element from './Element';\nimport StyleFilter from './StyleFilter';\nimport {\n  Attributes,\n  AttributeValue,\n  ChildrenNode,\n  ElementAttributes,\n  ElementProps,\n  FilterInterface,\n  MatcherElementsMap,\n  MatcherInterface,\n  Node,\n  NodeConfig,\n  ParserProps,\n} from './types';\n\nconst ELEMENT_NODE = 1;\nconst TEXT_NODE = 3;\nconst INVALID_ROOTS = /^<(!doctype|(html|head|body)(\\s|>))/i;\nconst ALLOWED_ATTRS = /^(aria-|data-|\\w+:)/iu;\nconst OPEN_TOKEN = /{{{(\\w+)\\/?}}}/;\n\nfunction createDocument() {\n  // Maybe SSR? Just do nothing instead of crashing!\n  if (typeof window === 'undefined' || typeof document === 'undefined') {\n    return undefined;\n  }\n\n  return document.implementation.createHTMLDocument('Interweave');\n}\n\nexport default class Parser {\n  allowed: Set<string>;\n\n  banned: Set<string>;\n\n  blocked: Set<string>;\n\n  container?: HTMLElement;\n\n  content: Node[] = [];\n\n  props: ParserProps;\n\n  matchers: MatcherInterface[];\n\n  filters: FilterInterface[];\n\n  keyIndex: number;\n\n  constructor(\n    markup: string,\n    props: ParserProps = {},\n    matchers: MatcherInterface[] = [],\n    filters: FilterInterface[] = [],\n  ) {\n    if (__DEV__) {\n      if (markup && typeof markup !== 'string') {\n        throw new TypeError('Interweave parser requires a valid string.');\n      }\n    }\n\n    this.props = props;\n    this.matchers = matchers;\n    this.filters = [...filters, new StyleFilter()];\n    this.keyIndex = -1;\n    this.container = this.createContainer(markup || '');\n    this.allowed = new Set(props.allowList || ALLOWED_TAG_LIST);\n    this.banned = new Set(BANNED_TAG_LIST);\n    this.blocked = new Set(props.blockList);\n  }\n\n  /**\n   * Loop through and apply all registered attribute filters.\n   */\n  applyAttributeFilters<K extends keyof ElementAttributes>(\n    name: K,\n    value: ElementAttributes[K],\n  ): ElementAttributes[K] {\n    return this.filters.reduce(\n      (nextValue, filter) =>\n        nextValue !== null && typeof filter.attribute === 'function'\n          ? filter.attribute(name, nextValue)\n          : nextValue,\n      value,\n    );\n  }\n\n  /**\n   * Loop through and apply all registered node filters.\n   */\n  applyNodeFilters(name: string, node: HTMLElement | null): HTMLElement | null {\n    // Allow null to be returned\n    return this.filters.reduce(\n      (nextNode, filter) =>\n        nextNode !== null && typeof filter.node === 'function'\n          ? filter.node(name, nextNode)\n          : nextNode,\n      node,\n    );\n  }\n\n  /**\n   * Loop through and apply all registered matchers to the string.\n   * If a match is found, create a React element, and build a new array.\n   * This array allows React to interpolate and render accordingly.\n   */\n  applyMatchers(string: string, parentConfig: NodeConfig): ChildrenNode {\n    const elements: MatcherElementsMap = {};\n    const { props } = this;\n    let matchedString = string;\n    let elementIndex = 0;\n    let parts = null;\n\n    this.matchers.forEach((matcher) => {\n      const tagName = matcher.asTag().toLowerCase();\n      const config = this.getTagConfig(tagName);\n\n      // Skip matchers that have been disabled from props or are not supported\n      if (\n        (props as { [key: string]: unknown })[matcher.inverseName] ||\n        !this.isTagAllowed(tagName)\n      ) {\n        return;\n      }\n\n      // Skip matchers in which the child cannot be rendered\n      if (!this.canRenderChild(parentConfig, config)) {\n        return;\n      }\n\n      // Continuously trigger the matcher until no matches are found\n      let tokenizedString = '';\n\n      while (matchedString && (parts = matcher.match(matchedString))) {\n        const { index, length, match, valid, void: isVoid, ...partProps } = parts;\n        const tokenName = matcher.propName + elementIndex;\n\n        // Piece together a new string with interpolated tokens\n        if (index > 0) {\n          tokenizedString += matchedString.slice(0, index);\n        }\n\n        if (valid) {\n          tokenizedString += isVoid\n            ? `{{{${tokenName}/}}}`\n            : `{{{${tokenName}}}}${match}{{{/${tokenName}}}}`;\n\n          this.keyIndex += 1;\n\n          elementIndex += 1;\n          elements[tokenName] = {\n            children: match,\n            matcher,\n            props: {\n              ...props,\n              ...partProps,\n              key: this.keyIndex,\n            },\n          };\n        } else {\n          tokenizedString += match;\n        }\n\n        // Reduce the string being matched against,\n        // otherwise we end up in an infinite loop!\n        if (matcher.greedy) {\n          matchedString = tokenizedString + matchedString.slice(index + length);\n          tokenizedString = '';\n        } else {\n          // eslint-disable-next-line unicorn/explicit-length-check\n          matchedString = matchedString.slice(index + (length || match.length));\n        }\n      }\n\n      // Update the matched string with the tokenized string,\n      // so that the next matcher can apply to it.\n      if (!matcher.greedy) {\n        matchedString = tokenizedString + matchedString;\n      }\n    });\n\n    if (elementIndex === 0) {\n      return string;\n    }\n\n    return this.replaceTokens(matchedString, elements);\n  }\n\n  /**\n   * Determine whether the child can be rendered within the parent.\n   */\n  canRenderChild(parentConfig: NodeConfig, childConfig: NodeConfig): boolean {\n    if (!parentConfig.tagName || !childConfig.tagName) {\n      return false;\n    }\n\n    // No children\n    if (parentConfig.void) {\n      return false;\n    }\n\n    // Valid children\n    if (parentConfig.children.length > 0) {\n      return parentConfig.children.includes(childConfig.tagName);\n    }\n\n    if (parentConfig.invalid.length > 0 && parentConfig.invalid.includes(childConfig.tagName)) {\n      return false;\n    }\n\n    // Valid parent\n    if (childConfig.parent.length > 0) {\n      return childConfig.parent.includes(parentConfig.tagName);\n    }\n\n    // Self nesting\n    if (!parentConfig.self && parentConfig.tagName === childConfig.tagName) {\n      return false;\n    }\n\n    // Content category type\n    return Boolean(parentConfig && parentConfig.content & childConfig.type);\n  }\n\n  /**\n   * Convert line breaks in a string to HTML `<br/>` tags.\n   * If the string contains HTML, we should not convert anything,\n   * as line breaks should be handled by `<br/>`s in the markup itself.\n   */\n  convertLineBreaks(markup: string): string {\n    const { noHtml, disableLineBreaks } = this.props;\n\n    if (noHtml || disableLineBreaks || markup.match(/<((?:\\/[ a-z]+)|(?:[ a-z]+\\/))>/gi)) {\n      return markup;\n    }\n\n    // Replace carriage returns\n    let nextMarkup = markup.replace(/\\r\\n/g, '\\n');\n\n    // Replace long line feeds\n    nextMarkup = nextMarkup.replace(/\\n{3,}/g, '\\n\\n\\n');\n\n    // Replace line feeds with `<br/>`s\n    nextMarkup = nextMarkup.replace(/\\n/g, '<br/>');\n\n    return nextMarkup;\n  }\n\n  /**\n   * Create a detached HTML document that allows for easy HTML\n   * parsing while not triggering scripts or loading external\n   * resources.\n   */\n  createContainer(markup: string): HTMLElement | undefined {\n    const factory =\n      (typeof global !== 'undefined' && global.INTERWEAVE_SSR_POLYFILL) || createDocument;\n    const doc = factory();\n\n    if (!doc) {\n      return undefined;\n    }\n\n    const tag = this.props.containerTagName || 'body';\n    const el = tag === 'body' || tag === 'fragment' ? doc.body : doc.createElement(tag);\n\n    if (markup.match(INVALID_ROOTS)) {\n      if (__DEV__) {\n        throw new Error('HTML documents as Interweave content are not supported.');\n      }\n    } else {\n      el.innerHTML = this.convertLineBreaks(this.props.escapeHtml ? escapeHtml(markup) : markup);\n    }\n\n    return el;\n  }\n\n  /**\n   * Convert an elements attribute map to an object map.\n   * Returns null if no attributes are defined.\n   */\n  extractAttributes(node: HTMLElement): Attributes | null {\n    const { allowAttributes } = this.props;\n    const attributes: Attributes = {};\n    let count = 0;\n\n    if (node.nodeType !== ELEMENT_NODE || !node.attributes) {\n      return null;\n    }\n\n    Array.from(node.attributes).forEach((attr) => {\n      const { name, value } = attr;\n      const newName = name.toLowerCase();\n      const filter = ATTRIBUTES[newName] || ATTRIBUTES[name];\n\n      // Verify the node is safe from attacks\n      if (!this.isSafe(node)) {\n        return;\n      }\n\n      // Do not allow denied attributes, excluding ARIA attributes\n      // Do not allow events or XSS injections\n      if (!newName.match(ALLOWED_ATTRS)) {\n        if (\n          (!allowAttributes && (!filter || filter === FILTER_DENY)) ||\n          newName.startsWith('on') ||\n          value.replace(/(\\s|\\0|&#x0([9AD]);)/, '').match(/(javascript|vbscript|livescript|xss):/i)\n        ) {\n          return;\n        }\n      }\n\n      // Apply attribute filters\n      let newValue: AttributeValue = newName === 'style' ? this.extractStyleAttribute(node) : value;\n\n      // Cast to boolean\n      if (filter === FILTER_CAST_BOOL) {\n        newValue = true;\n\n        // Cast to number\n      } else if (filter === FILTER_CAST_NUMBER) {\n        newValue = Number.parseFloat(String(newValue));\n\n        // Cast to string\n      } else if (filter !== FILTER_NO_CAST) {\n        newValue = String(newValue);\n      }\n\n      attributes[ATTRIBUTES_TO_PROPS[newName] || newName] = this.applyAttributeFilters(\n        newName as keyof ElementAttributes,\n        newValue,\n      ) as AttributeValue;\n      count += 1;\n    });\n\n    if (count === 0) {\n      return null;\n    }\n\n    return attributes;\n  }\n\n  /**\n   * Extract the style attribute as an object and remove values that allow for attack vectors.\n   */\n  extractStyleAttribute(node: HTMLElement): object {\n    const styles: { [key: string]: number | string } = {};\n\n    Array.from(node.style).forEach((key) => {\n      const value = node.style[key as keyof CSSStyleDeclaration];\n\n      if (typeof value === 'string' || typeof value === 'number') {\n        styles[key.replace(/-([a-z])/g, (match, letter) => letter.toUpperCase())] = value;\n      }\n    });\n\n    return styles;\n  }\n\n  /**\n   * Return configuration for a specific tag.\n   */\n  getTagConfig(tagName: string): NodeConfig {\n    const common = {\n      children: [],\n      content: 0,\n      invalid: [],\n      parent: [],\n      self: true,\n      tagName: '',\n      type: 0,\n      void: false,\n    };\n\n    // Only spread when a tag config exists,\n    // otherwise we use the empty `tagName`\n    // for parent config inheritance.\n    if (TAGS[tagName]) {\n      return {\n        ...common,\n        ...TAGS[tagName],\n        tagName,\n      };\n    }\n\n    return common;\n  }\n\n  /**\n   * Verify that a node is safe from XSS and injection attacks.\n   */\n  isSafe(node: HTMLElement): boolean {\n    // URLs should only support HTTP, email and phone numbers\n    if (typeof HTMLAnchorElement !== 'undefined' && node instanceof HTMLAnchorElement) {\n      const href = node.getAttribute('href');\n\n      // Fragment protocols start with about:\n      // So let's just allow them\n      if (href && href.charAt(0) === '#') {\n        return true;\n      }\n\n      const protocol = node.protocol.toLowerCase();\n\n      return (\n        protocol === ':' ||\n        protocol === 'http:' ||\n        protocol === 'https:' ||\n        protocol === 'mailto:' ||\n        protocol === 'tel:'\n      );\n    }\n\n    return true;\n  }\n\n  /**\n   * Verify that an HTML tag is allowed to render.\n   */\n  isTagAllowed(tagName: string): boolean {\n    if (this.banned.has(tagName) || this.blocked.has(tagName)) {\n      return false;\n    }\n\n    return this.props.allowElements || this.allowed.has(tagName);\n  }\n\n  /**\n   * Parse the markup by injecting it into a detached document,\n   * while looping over all child nodes and generating an\n   * array to interpolate into JSX.\n   */\n  parse(): Node[] {\n    if (!this.container) {\n      return [];\n    }\n\n    return this.parseNode(this.container, this.getTagConfig(this.container.nodeName.toLowerCase()));\n  }\n\n  /**\n   * Loop over the nodes children and generate a\n   * list of text nodes and React elements.\n   */\n  parseNode(parentNode: HTMLElement, parentConfig: NodeConfig): Node[] {\n    const {\n      noHtml,\n      noHtmlExceptMatchers,\n      allowElements,\n      transform,\n      transformOnlyAllowList,\n    } = this.props;\n    let content: Node[] = [];\n    let mergedText = '';\n\n    Array.from(parentNode.childNodes).forEach((node) => {\n      // Create React elements from HTML elements\n      if (node.nodeType === ELEMENT_NODE) {\n        const tagName = node.nodeName.toLowerCase();\n        const config = this.getTagConfig(tagName);\n\n        // Persist any previous text\n        if (mergedText) {\n          content.push(mergedText);\n          mergedText = '';\n        }\n\n        // Apply node filters first\n        const nextNode = this.applyNodeFilters(tagName, node as HTMLElement);\n\n        if (!nextNode) {\n          return;\n        }\n\n        // Apply transformation second\n        let children;\n\n        if (transform && !(transformOnlyAllowList && !this.isTagAllowed(tagName))) {\n          this.keyIndex += 1;\n          const key = this.keyIndex;\n\n          // Must occur after key is set\n          children = this.parseNode(nextNode, config);\n\n          const transformed = transform(nextNode, children, config);\n\n          if (transformed === null) {\n            return;\n          } else if (typeof transformed !== 'undefined') {\n            content.push(React.cloneElement(transformed as React.ReactElement<unknown>, { key }));\n\n            return;\n          }\n\n          // Reset as we're not using the transformation\n          this.keyIndex = key - 1;\n        }\n\n        // Never allow these tags (except via a transformer)\n        if (this.banned.has(tagName)) {\n          return;\n        }\n\n        // Only render when the following criteria is met:\n        //  - HTML has not been disabled\n        //  - Tag is allowed\n        //  - Child is valid within the parent\n        if (\n          !(noHtml || (noHtmlExceptMatchers && tagName !== 'br')) &&\n          this.isTagAllowed(tagName) &&\n          (allowElements || this.canRenderChild(parentConfig, config))\n        ) {\n          this.keyIndex += 1;\n\n          // Build the props as it makes it easier to test\n          const attributes = this.extractAttributes(nextNode);\n          const elementProps: ElementProps = {\n            tagName,\n          };\n\n          if (attributes) {\n            elementProps.attributes = attributes;\n          }\n\n          if (config.void) {\n            elementProps.selfClose = config.void;\n          }\n\n          content.push(\n            React.createElement(\n              Element,\n              { ...elementProps, key: this.keyIndex },\n              children || this.parseNode(nextNode, config),\n            ),\n          );\n\n          // Render the children of the current element only.\n          // Important: If the current element is not allowed,\n          // use the parent element for the next scope.\n        } else {\n          content = content.concat(\n            this.parseNode(nextNode, config.tagName ? config : parentConfig),\n          );\n        }\n\n        // Apply matchers if a text node\n      } else if (node.nodeType === TEXT_NODE) {\n        const text =\n          noHtml && !noHtmlExceptMatchers\n            ? node.textContent\n            : this.applyMatchers(node.textContent || '', parentConfig);\n\n        if (Array.isArray(text)) {\n          content = content.concat(text);\n        } else {\n          mergedText += text;\n        }\n      }\n    });\n\n    if (mergedText) {\n      content.push(mergedText);\n    }\n\n    return content;\n  }\n\n  /**\n   * Deconstruct the string into an array, by replacing custom tokens with React elements,\n   * so that React can render it correctly.\n   */\n  replaceTokens(tokenizedString: string, elements: MatcherElementsMap): ChildrenNode {\n    if (!tokenizedString.includes('{{{')) {\n      return tokenizedString;\n    }\n\n    const nodes: Node[] = [];\n    let text = tokenizedString;\n    let open: RegExpMatchArray | null = null;\n\n    // Find an open token tag\n    while ((open = text.match(OPEN_TOKEN))) {\n      const [match, tokenName] = open;\n      const startIndex = open.index!;\n      const isVoid = match.includes('/');\n\n      if (__DEV__) {\n        if (!elements[tokenName]) {\n          throw new Error(`Token \"${tokenName}\" found but no matching element to replace with.`);\n        }\n      }\n\n      // Extract the previous non-token text\n      if (startIndex > 0) {\n        nodes.push(text.slice(0, startIndex));\n\n        // Reduce text so that the closing tag will be found after the opening\n        text = text.slice(startIndex);\n      }\n\n      const { children, matcher, props: elementProps } = elements[tokenName];\n      let endIndex: number;\n\n      // Use tag as-is if void\n      if (isVoid) {\n        endIndex = match.length;\n\n        nodes.push(matcher.createElement(children, elementProps));\n\n        // Find the closing tag if not void\n      } else {\n        const close = text.match(new RegExp(`{{{/${tokenName}}}}`))!;\n\n        if (__DEV__) {\n          if (!close) {\n            throw new Error(`Closing token missing for interpolated element \"${tokenName}\".`);\n          }\n        }\n\n        endIndex = close.index! + close[0].length;\n\n        nodes.push(\n          matcher.createElement(\n            this.replaceTokens(text.slice(match.length, close.index!), elements),\n            elementProps,\n          ),\n        );\n      }\n\n      // Reduce text for the next interation\n      text = text.slice(endIndex);\n    }\n\n    // Extra the remaining text\n    if (text.length > 0) {\n      nodes.push(text);\n    }\n\n    // Reduce to a string if possible\n    if (nodes.length === 0) {\n      return '';\n    } else if (nodes.length === 1 && typeof nodes[0] === 'string') {\n      return nodes[0];\n    }\n\n    return nodes;\n  }\n}\n","/* eslint-disable react/jsx-fragments */\n\nimport React from 'react';\nimport Element from './Element';\nimport Parser from './Parser';\nimport { MarkupProps } from './types';\n\nexport default function Markup(props: MarkupProps) {\n  const {\n    attributes,\n    className,\n    containerTagName,\n    content,\n    emptyContent,\n    parsedContent,\n    tagName,\n  } = props;\n  const tag = containerTagName || tagName || 'span';\n  const noWrap = tag === 'fragment' ? true : props.noWrap;\n  let mainContent;\n\n  if (parsedContent) {\n    mainContent = parsedContent;\n  } else {\n    const markup = new Parser(content || '', props).parse();\n\n    if (markup.length > 0) {\n      mainContent = markup;\n    }\n  }\n\n  if (!mainContent) {\n    mainContent = emptyContent;\n  }\n\n  if (noWrap) {\n    // eslint-disable-next-line react/jsx-no-useless-fragment\n    return <React.Fragment>{mainContent}</React.Fragment>;\n  }\n\n  return (\n    <Element attributes={attributes} className={className} tagName={tag}>\n      {mainContent}\n    </Element>\n  );\n}\n","import React from 'react';\nimport Markup from './Markup';\nimport Parser from './Parser';\nimport { InterweaveProps } from './types';\n\nexport default function Interweave(props: InterweaveProps) {\n  const {\n    attributes,\n    className,\n    content = '',\n    disableFilters = false,\n    disableMatchers = false,\n    emptyContent = null,\n    filters = [],\n    matchers = [],\n    onAfterParse = null,\n    onBeforeParse = null,\n    tagName = 'span',\n    noWrap = false,\n    ...parserProps\n  } = props;\n  const allMatchers = disableMatchers ? [] : matchers;\n  const allFilters = disableFilters ? [] : filters;\n  const beforeCallbacks = onBeforeParse ? [onBeforeParse] : [];\n  const afterCallbacks = onAfterParse ? [onAfterParse] : [];\n\n  // Inherit callbacks from matchers\n  allMatchers.forEach((matcher) => {\n    if (matcher.onBeforeParse) {\n      beforeCallbacks.push(matcher.onBeforeParse.bind(matcher));\n    }\n\n    if (matcher.onAfterParse) {\n      afterCallbacks.push(matcher.onAfterParse.bind(matcher));\n    }\n  });\n\n  // Trigger before callbacks\n  const markup = beforeCallbacks.reduce((string, callback) => {\n    const nextString = callback(string, props);\n\n    if (__DEV__) {\n      if (typeof nextString !== 'string') {\n        throw new TypeError('Interweave `onBeforeParse` must return a valid HTML string.');\n      }\n    }\n\n    return nextString;\n  }, content || '');\n\n  // Parse the markup\n  const parser = new Parser(markup, parserProps, allMatchers, allFilters);\n\n  // Trigger after callbacks\n  const nodes = afterCallbacks.reduce((parserNodes, callback) => {\n    const nextNodes = callback(parserNodes, props);\n\n    if (__DEV__) {\n      if (!Array.isArray(nextNodes)) {\n        throw new TypeError(\n          'Interweave `onAfterParse` must return an array of strings and React elements.',\n        );\n      }\n    }\n\n    return nextNodes;\n  }, parser.parse());\n\n  return (\n    <Markup\n      attributes={attributes}\n      className={className}\n      containerTagName={props.containerTagName}\n      emptyContent={emptyContent}\n      tagName={tagName}\n      noWrap={noWrap}\n      parsedContent={nodes.length === 0 ? undefined : nodes}\n    />\n  );\n}\n","import { MatchCallback, MatchResponse } from './types';\n\n/**\n * Trigger the actual pattern match and package the matched\n * response through a callback.\n */\nexport default function match<T>(\n  string: string,\n  pattern: RegExp | string,\n  callback: MatchCallback<T>,\n  isVoid: boolean = false,\n): MatchResponse<T> | null {\n  const matches = string.match(pattern instanceof RegExp ? pattern : new RegExp(pattern, 'i'));\n\n  if (!matches) {\n    return null;\n  }\n\n  return {\n    match: matches[0],\n    void: isVoid,\n    ...callback(matches),\n    index: matches.index!,\n    length: matches[0].length,\n    valid: true,\n  };\n}\n","import React from 'react';\nimport match from './match';\nimport { ChildrenNode, MatchCallback, MatcherInterface, MatchResponse, Node } from './types';\n\nexport default abstract class Matcher<Props extends object = {}, Options extends object = {}>\n  implements MatcherInterface<Props> {\n  greedy: boolean = false;\n\n  options: Options;\n\n  propName: string;\n\n  inverseName: string;\n\n  factory: React.ComponentType<Props> | null;\n\n  constructor(name: string, options?: Options, factory?: React.ComponentType<Props> | null) {\n    if (__DEV__) {\n      if (!name || name.toLowerCase() === 'html') {\n        throw new Error(`The matcher name \"${name}\" is not allowed.`);\n      }\n    }\n\n    // @ts-expect-error\n    this.options = { ...options };\n    this.propName = name;\n    this.inverseName = `no${name.charAt(0).toUpperCase() + name.slice(1)}`;\n    this.factory = factory || null;\n  }\n\n  /**\n   * Attempts to create a React element using a custom user provided factory,\n   * or the default matcher factory.\n   */\n  createElement(children: ChildrenNode, props: Props): Node {\n    const element = this.factory\n      ? React.createElement(this.factory, props, children)\n      : this.replaceWith(children, props);\n\n    if (__DEV__) {\n      if (typeof element !== 'string' && !React.isValidElement(element)) {\n        throw new Error(`Invalid React element created from ${this.constructor.name}.`);\n      }\n    }\n\n    return element;\n  }\n\n  /**\n   * Trigger the actual pattern match and package the matched\n   * response through a callback.\n   */\n  doMatch<T>(\n    string: string,\n    pattern: RegExp | string,\n    callback: MatchCallback<T>,\n    isVoid: boolean = false,\n  ): MatchResponse<T> | null {\n    return match(string, pattern, callback, isVoid);\n  }\n\n  /**\n   * Callback triggered before parsing.\n   */\n  onBeforeParse(content: string, props: Props): string {\n    return content;\n  }\n\n  /**\n   * Callback triggered after parsing.\n   */\n  onAfterParse(content: Node[], props: Props): Node[] {\n    return content;\n  }\n\n  /**\n   * Replace the match with a React element based on the matched token and optional props.\n   */\n  abstract replaceWith(children: ChildrenNode, props: Props): Node;\n\n  /**\n   * Defines the HTML tag name that the resulting React element will be.\n   */\n  abstract asTag(): string;\n\n  /**\n   * Attempt to match against the defined string. Return `null` if no match found,\n   * else return the `match` and any optional props to pass along.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  abstract match(string: string): MatchResponse<any> | null;\n}\n","/**\n * @copyright   2016-2019, Miles Johnson\n * @license     https://opensource.org/licenses/MIT\n */\n\nimport Element from './Element';\nimport Filter from './Filter';\nimport Interweave from './Interweave';\nimport Markup from './Markup';\nimport match from './match';\nimport Matcher from './Matcher';\nimport Parser from './Parser';\n\nexport { Element, Filter, Markup, match, Matcher, Parser };\n\nexport * from './constants';\nexport * from './types';\n\nexport default Interweave;\n"]},"metadata":{},"sourceType":"module"}